######################################################################
# Originating, Initial Requests with PLMN-based Service-Route Support
######################################################################
route[MO]
{
	# Strip Transport from RURI:
	$ru = $(ru{re.subst,/;transport=[A-Za-z]*//g});
	xnotice("PCSCF MO: \n Destination URI: $du\n Request URI: $ru\n");
	xnotice("Source IP and Port: ($si:$sp)\n Route-URI: $route_uri\n");
	xnotice("Received IP and Port: ($Ri:$Rp)\n");
	xnotice("Contact header: $ct\n");

#!ifdef WITH_MULTIPLMN
	# Extract PLMN information for dynamic routing
	if($avp(plmn_full) == $null || $avp(plmn_full) == "") {
		route(EXTRACT_PLMN_INFO);
	}
	xlog("L_INFO", "PCSCF MO: Processing request for PLMN: $avp(plmn_full) ($avp(plmn_id))\n");
	
	# Enhanced logging for roaming users
	if(isflagset(FLT_ROAMING)) {
		xlog("L_INFO", "PCSCF MO: Roaming user from PLMN: $avp(plmn_id)\n");
	}
#!endif

	# Process route headers, if any:
	loose_route();
	if (!pcscf_is_registered("location")) {
		send_reply("403","Forbidden - You must register first with a S-CSCF");
		exit;
	}

	# We do not trust the user, let's remove the P-Asserted-Identity, if any:
	remove_hf("P-Asserted-Identity");
	remove_hf("P-Preferred-Identity");

#!ifdef WITH_MULTIPLMN
	# Add P-Charging-Vector with PLMN-specific information
	if(isflagset(FLT_ROAMING)) {
		# For roaming users, add orig-ioi and term-ioi
		sip_p_charging_vector("g");
		if(!is_present_hf("P-Charging-Vector")) {
			append_hf("P-Charging-Vector: icid-value=$ci-pcscf; orig-ioi=ims.mnc$avp(plmn_mnc).mcc$avp(plmn_mcc).3gppnetwork.org; term-ioi=ims.mnc080.mcc432.3gppnetwork.org\r\n");
		}
	} else {
		# For home network users
		sip_p_charging_vector("g");
	}
#!else
	# Add P-Charging-Vector
	sip_p_charging_vector("g");
#!endif

	if (is_present_hf("P-Preferred-Identity") && pcscf_assert_identity("location", "$hdr(P-Preferred-Identity)") && $hdr(P-Preferred-Identity) =~ "sip:.*") {
		append_hf("P-Asserted-Identity: $hdr(P-Preferred-Identity)\r\n");
	} else if (is_present_hf("P-Asserted-Identity") && pcscf_assert_identity("location", "$hdr(P-Asserted-Identity)") && $hdr(P-Asserted-Identity) =~ "sip:.*") {
		append_hf("P-Asserted-Identity: $hdr(P-Asserted-Identity)\r\n");
	} else if (pcscf_assert_identity("location", "$(fu{tobody.uri})")) {
#!ifdef WITH_MULTIPLMN
		# Enhanced identity handling for multi-PLMN scenarios
		if ($fu =~ "tel:.*") {
			if(isflagset(FLT_ROAMING)) {
				# For roaming users, use their home network domain
				$var(new_hdr) = $(fu{tobody.uri}) + "@ims.mnc$avp(plmn_mnc).mcc$avp(plmn_mcc).3gppnetwork.org";
			} else {
				# For home users, use default network name
				$var(new_hdr) = $(fu{tobody.uri}) + "@ims.mnc080.mcc432.3gppnetwork.org";
			}
			$var(new_hdr) = $(var(new_hdr){re.subst,/tel:/sip:/g});
			append_hf("P-Asserted-Identity: <$var(new_hdr)>\r\n");
			$fu = $var(new_hdr);
		} else {
			append_hf("P-Asserted-Identity: <$(fu{tobody.uri})>\r\n");
		}
#!else
		# For broken SIP implementation in Samsung devices
		if ($fu =~ "tel:.*") {
			$var(new_hdr) = $(fu{tobody.uri}) + "@NETWORKNAME";
			$var(new_hdr) = $(var(new_hdr){re.subst,/tel:/sip:/g});
			append_hf("P-Asserted-Identity: <$var(new_hdr)>\r\n");
			$fu = $var(new_hdr);
		} else {
			append_hf("P-Asserted-Identity: <$(fu{tobody.uri})>\r\n");
		}
#!endif
	} else {
		append_hf("P-Asserted-Identity: <$pcscf_asserted_identity>\r\n");
	}

	# Enhanced service route validation and enforcement for Multi-PLMN
	# if (!pcscf_follows_service_routes("location")) {
	# 	$var(scscf_domain) = $sht(plmn_scscf_mapping=>$avp(plmn_full));
	# 	if ($var(scscf_domain) != $null && $var(scscf_domain) != "") {
	# 		$var(expected_route) = "sip:orig@" + $var(scscf_domain) + ":6060";
	# 		# if (!($route_uri =~ "^sip:orig@" + $var(scscf_domain) + ":6060(;.*)?$")) {
	# 		# 	xlog("L_WARN", "PCSCF MO: Route mismatch for PLMN $avp(plmn_full). Expected: $var(expected_route), Got: $route_uri\n");
	# 		# 	pcscf_force_service_routes("location");
	# 		# }
	# 		# else {
	# 		# 	xlog("L_INFO", "PCSCF MO: Route matches expected PLMN-specific service route: $var(expected_route)\n");
	# 		# }
	# 	} else {
	# 		xlog("L_WARN", "PCSCF MO: No S-CSCF domain mapping found for PLMN $avp(plmn_full), enforcing standard service route.\n");
	# 		pcscf_force_service_routes("location");
	# 	}
	# }
	if (!pcscf_follows_service_routes("location")) {
		pcscf_force_service_routes("location");
	}

	# add IBCF/THIG route here if required
	# Check for "sec-agree" in the Require header:
	if (is_present_hf("Require") && $hdr(Require) =~ ".*sec-agree.*") {
		# Remove the old Require-Header:
		remove_hf("Require");
		# Replace ", sec-agree" with ""
		$var(new_hdr) = $(hdr(Require){re.subst,/[, ]*sec-agree//gi});
		if ($(var(new_hdr){s.len}) > 0) {
			append_hf("Require: $var(new_hdr)\r\n");
		}
	}

	# Check for "sec-agree" in the Proxy-Require header:
	if (is_present_hf("Proxy-Require") && $hdr(Proxy-Require) =~ ".*sec-agree.*") {
		# Remove the old Proxy-Require-Header:		
		remove_hf("Proxy-Require");
		# Replace ", sec-agree" with ""
		$var(new_hdr) = $(hdr(Proxy-Require){re.subst,/[, ]*sec-agree//gi});
		if ($(var(new_hdr){s.len}) > 0) {
			append_hf("Proxy-Require: $var(new_hdr)\r\n");
		}
		}
	remove_hf("Security-Verify");

#!ifdef TRF_FUNCTION
	$var(trf) = TRF_FUNCTION;
	# Check for "Feature-Caps" header and add TRF information:
	if (is_present_hf("Feature-Caps")) {
		# Remove the old Feature-Caps-Header:		
		remove_hf("Feature-Caps");
		append_hf("Feature-Caps: $hdr(Feature-Caps);+g.3gpp.trf=\"<sip:$var(trf);lr>\"\r\n");
		} else {
		append_hf("Feature-Caps: *;+g.3gpp.trf=\"<sip:$var(trf);lr>\"\r\n");
	}
#!endif	

#!ifdef WITH_MULTIPLMN
	# Enhanced P-Visited-Network-ID handling based on PLMN
	if (is_present_hf("P-Visited-Network-ID")) {
		$var(existing_visited) = $hdr(P-Visited-Network-ID);
		# For roaming users, add home network as the visited network
		if(isflagset(FLT_ROAMING)) {
			$var(new_hdr) = "ims.mnc080.mcc432.3gppnetwork.org, "+$var(existing_visited);
		} else {
			$var(new_hdr) = "ims.mnc080.mcc432.3gppnetwork.org, "+$var(existing_visited);
		}
		remove_hf("P-Visited-Network-ID");
		append_hf("P-Visited-Network-ID: $var(new_hdr)\r\n");
	} else {
		# Add appropriate visited network based on context
		if(isflagset(FLT_ROAMING)) {
			append_hf("P-Visited-Network-ID: ims.mnc080.mcc432.3gppnetwork.org\r\n");
		} else {
			append_hf("P-Visited-Network-ID: ims.mnc080.mcc432.3gppnetwork.org\r\n");
		}
	}
	
	# Add P-Access-Network-Info for enhanced PLMN support
	if(!is_present_hf("P-Access-Network-Info") && is_method("INVITE")) {
		if(isflagset(FLT_ROAMING)) {
			append_hf("P-Access-Network-Info: 3GPP-E-UTRAN; utran-cell-id-3gpp=$avp(plmn_mcc):$avp(plmn_mnc)\r\n");
		} else {
			append_hf("P-Access-Network-Info: 3GPP-E-UTRAN; utran-cell-id-3gpp=432:080\r\n");
		}
	}
#!else
	# Add a visited Network-ID-Header:
	if (is_present_hf("P-Visited-Network-ID")) {
		$var(new_hdr) = "NETWORKNAME, "+$hdr(P-Visited-Network-ID);
		append_hf("P-Visited-Network-ID: $var(new_hdr)\r\n");
	} else {
		append_hf("P-Visited-Network-ID: NETWORKNAME\r\n");
	}
#!endif

	set_dlg_profile("orig");
	t_on_reply("MO_reply");

#!ifdef WITH_MULTIPLMN
	xlog("L_INFO", "PCSCF MO: Processed originating request for PLMN $avp(plmn_full), routing context: $avp(routing_context)\n");
#!endif
}

######################################################################
# Replies to Originating Initial Requests with Multi-PLMN Support
######################################################################
onreply_route[MO_reply] {
	xnotice("PCSCF MO_reply: \n Destination URI: $du\n Request URI: $ru\n");
	xnotice("Source IP and Port: ($si:$sp)\n Route-URI: $route_uri\n");
	xnotice("Received IP and Port: ($Ri:$Rp)\n");
	xnotice("Contact header: $ct\n");

#!ifdef WITH_MULTIPLMN
	# Enhanced logging for roaming scenarios
	if(isflagset(FLT_ROAMING)) {
		xlog("L_INFO", "PCSCF MO_reply: Reply for roaming user from PLMN: $avp(plmn_id)\n");
	}
#!endif

	if (is_present_hf("C-Params")) {
		remove_hf("Contact");
		remove_hf("C-Params");	
		append_hf("Contact: $ct;$hdr(C-Params)\r\n");
	}

#!ifdef WITH_IPSEC
	ipsec_forward("location", IPSEC_FORWARD_FLAGS);
#!endif

	# In case of 1xx and 2xx do NAT
	if(status=~"[12][0-9][0-9]")
		route(NATMANAGE);

#!ifdef WITH_RX
		if (t_check_status("183|200") && has_body("application/sdp")){
		xlog("L_DBG", "IMS: Received 183/200 inside orig_initial_reply\n");

		if (t_is_retr_async_reply()) {
					xlog("L_DBG", "Dropping retransmitted reply which is still currently suspended\n");
					drop();
			}

#!ifdef WITH_MULTIPLMN
		# Enhanced Rx handling for Multi-PLMN
		if(isflagset(FLT_ROAMING)) {
			xlog("L_DBG","Diameter: Orig authorizing media via Rx for roaming user from PLMN $avp(plmn_id)\n");
		} else {
			xlog("L_DBG","Diameter: Orig authorizing media via Rx for home user\n");
		}
#!else
		xlog("L_DBG","Diameter: Orig authorizing media via Rx\n");
#!endif
		
		$avp(FTAG_CUSTOM_AVP)=$ft;
		$avp(TTAG_CUSTOM_AVP)=$tt;
		$avp(CALLID_CUSTOM_AVP)=$ci;

		if (Rx_AAR("MO_aar_reply","orig","",-1) == 0) {
			exit;
		}
	}
#!endif
}

route[MO_aar_reply]
{
		#this is async so to know status we have to check the reply avp
	switch ($avp(s:aar_return_code)) {
		case 1:
#!ifdef WITH_MULTIPLMN
			if(isflagset(FLT_ROAMING)) {
				xlog("L_DBG", "Diameter: Orig AAR success on media authorization for roaming user from PLMN $avp(plmn_id)\n");
			} else {
				xlog("L_DBG", "Diameter: Orig AAR success on media authorization for home user\n");
			}
#!else
			xlog("L_DBG", "Diameter: Orig AAR success on media authorization\n");
#!endif
			break;
		default:
#!ifdef WITH_MULTIPLMN
			if(isflagset(FLT_ROAMING)) {
				xlog("L_ERR", "IMS: AAR failed Orig for roaming user from PLMN $avp(plmn_id)\n");
			} else {
				xlog("L_ERR", "IMS: AAR failed Orig for home user\n");
			}
#!else
			xlog("L_ERR", "IMS: AAR failed Orig\n");
#!endif
					xlog("L_ERR", "IMS: ttag: "+ "$avp(TTAG_CUSTOM_AVP)");
					xlog("L_ERR", "IMS: ftag: "+ "$avp(FTAG_CUSTOM_AVP)");
					xlog("L_ERR", "IMS: callid: "+ "$avp(CALLID_CUSTOM_AVP)");
			#comment this if you want to allow even if Rx fails
					if(dlg_get("$avp(CALLID_CUSTOM_AVP)","$avp(FTAG_CUSTOM_AVP)","$avp(TTAG_CUSTOM_AVP)")){
							dlg_terminate("all", "Sorry no QoS available");
							exit;
					}
	}
}

######################################################################
# In-Dialog-Mo-Requests with Multi-PLMN Support
######################################################################
route[MO_indialog] {
	xnotice("PCSCF MO_indialog: \n Destination URI: $du\n Request URI: $ru\n");
	xnotice("Source IP and Port: ($si:$sp)\n Route-URI: $route_uri\n");
	xnotice("Received IP and Port: ($Ri:$Rp)\n");
	xnotice("Contact header: $ct\n");

#!ifdef WITH_MULTIPLMN
	# Enhanced logging for in-dialog roaming requests
	if(isflagset(FLT_ROAMING)) {
		xlog("L_INFO", "PCSCF MO_indialog: In-dialog request for roaming user from PLMN: $avp(plmn_id)\n");
	}
	
	# Apply cached service route for the dialog if available
	if(is_method("SUBSCRIBE|REFER|UPDATE|INFO") && $sht(serviceroutes=>$ci) != $null) {
		$var(cached_route) = $sht(serviceroutes=>$ci);
		xlog("L_INFO", "PCSCF MO_indialog: Using cached service route for dialog $ci: $var(cached_route)\n");
	}
#!endif

	setflag(FLT_MOBILE_ORIG);
	t_on_reply("MO_indialog_reply");

	# Append rport only if its a request coming from UE
	if (is_request() && ($hdrc(Via) == 1)) {
		force_rport();
	}

#!ifdef WITH_IPSEC
	if ($dd != "" && $rd != "" && $fs != "") {
		if ($rd =~ ".*" + $dd + ".*") {
			ipsec_forward("location", IPSEC_FORWARD_FLAGS);
		}
	}
#!endif

#!ifdef WITH_MULTIPLMN
	xlog("L_INFO", "PCSCF MO_indialog: Processed in-dialog originating request for PLMN $avp(plmn_full)\n");
#!endif
}

onreply_route[MO_indialog_reply] {
	xnotice("PCSCF MO_indialog_reply: \n Destination URI: $du\n Request URI: $ru\n");
	xnotice("Source IP and Port: ($si:$sp)\n Route-URI: $route_uri\n");
	xnotice("Received IP and Port: ($Ri:$Rp)\n");
	xnotice("Contact header: $ct\n");

#!ifdef WITH_MULTIPLMN
	# Enhanced logging for in-dialog roaming replies
	if(isflagset(FLT_ROAMING)) {
		xlog("L_INFO", "PCSCF MO_indialog_reply: In-dialog reply for roaming user from PLMN: $avp(plmn_id)\n");
	}
#!endif

	# In case of 1xx and 2xx do NAT
	if(status=~"[12][0-9][0-9]")
		route(NATMANAGE);

#!ifdef WITH_RX
	if (t_check_status("183|200") && has_body("application/sdp") && !is_method("PRACK")) {
		if (t_is_retr_async_reply()) {
					xlog("L_DBG", "Dropping retransmitted reply which is still currently suspended\n");
					drop();
			}

#!ifdef WITH_MULTIPLMN
		if(isflagset(FLT_ROAMING)) {
			xlog("L_DBG", "IMS: ORIG_SUBSEQUENT reply for roaming user from PLMN $avp(plmn_id). This is a 200 OK to a re-INVITE\n");
			xlog("L_DBG","Diameter: Orig authorizing media via Rx for roaming user\n");
		} else {
			xlog("L_DBG", "IMS: ORIG_SUBSEQUENT reply for home user. This is a 200 OK to a re-INVITE\n");
			xlog("L_DBG","Diameter: Orig authorizing media via Rx for home user\n");
		}
#!else
			xlog("L_DBG", "IMS: ORIG_SUBSEQUENT reply. This is a 200 OK to a re-INVITE\n");
		xlog("L_DBG","Diameter: Orig authorizing media via Rx\n");
#!endif
		
		$avp(FTAG_CUSTOM_AVP)=$ft;
		$avp(TTAG_CUSTOM_AVP)=$tt;
		$avp(CALLID_CUSTOM_AVP)=$ci;

		if (Rx_AAR("MO_indialog_aar_reply","orig","",-1) == 0) {
			exit;
		}
	}
#!endif
}

route[MO_indialog_aar_reply]
{
		#this is async so to know status we have to check the reply avp
	switch ($avp(s:aar_return_code)) {
				case 1:
#!ifdef WITH_MULTIPLMN
			if(isflagset(FLT_ROAMING)) {
				xlog("L_DBG", "Diameter: Orig in-dialog AAR success on media authorization for roaming user from PLMN $avp(plmn_id)\n");
			} else {
				xlog("L_DBG", "Diameter: Orig in-dialog AAR success on media authorization for home user\n");
			}
#!else
						xlog("L_DBG", "Diameter: Orig AAR success on media authorization\n");
#!endif
						break;
				default:
#!ifdef WITH_MULTIPLMN
			if(isflagset(FLT_ROAMING)) {
				xlog("L_ERR", "IMS: In-dialog AAR failed Orig for roaming user from PLMN $avp(plmn_id)\n");
			} else {
				xlog("L_ERR", "IMS: In-dialog AAR failed Orig for home user\n");
			}
#!else
						xlog("L_ERR", "IMS: AAR failed Orig\n");
#!endif
						xlog("L_ERR", "IMS: ttag: "+ "$avp(TTAG_CUSTOM_AVP)");
						xlog("L_ERR", "IMS: ftag: "+ "$avp(FTAG_CUSTOM_AVP)");
						xlog("L_ERR", "IMS: callid: "+ "$avp(CALLID_CUSTOM_AVP)");
			#comment this if you want to allow even if Rx fails
						if(dlg_get("$avp(CALLID_CUSTOM_AVP)","$avp(FTAG_CUSTOM_AVP)","$avp(TTAG_CUSTOM_AVP)")){
								dlg_terminate("all", "Sorry no QoS available");
								exit;
						}
		}
}