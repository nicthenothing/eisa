######################################################################
# Route for handling Registrations with PLMN-based Service-Route:
######################################################################
route[REGISTER] {
	# Provide some statistics
	if ($sht(a=>$ci::start_time) == $null || $sht(a=>$ci::start_time) == 0) {
		$sht(a=>$ci::start_time) = $TV(Sn);
	}
	xnotice("PCSCF REGISTER: \n Destination URI: $du\n Request URI: $ru\n");
	xnotice("Source IP and Port: ($si:$sp)\n Route-URI: $route_uri\n");
	xnotice("Received IP and Port: ($Ri:$Rp)\n");
	xnotice("Contact header: $ct\n");

#!ifdef WITH_MULTIPLMN
	# Extract PLMN information for Service-Route generation
	route(EXTRACT_PLMN_INFO);
	xlog("L_INFO", "PCSCF REGISTER: Processing registration for PLMN: $avp(plmn_full) ($avp(plmn_id))\n");
#!endif

	# Strip Transport from RURI:
	$ru = $(ru{re.subst,/;transport=[A-Za-z]*//g});

	if (is_present_hf("Contact")) {
		pcscf_save_pending("location");
	} else {
		send_reply("403", "No contact header");
		exit;
	}

#!ifdef WITH_IPSEC
	$sht(ipsec_clients=>$(ct{nameaddr.uri})) = $null;
	if ($hdr(Security-Client) =~ ".*ipsec-3gpp.*") {
		$sht(ipsec_clients=>$(ct{nameaddr.uri})) = 1;
	}
#!endif

	# Strip additional Tags from RURI:
	if ($rU == $null)
		$ru = "sip:"+$rd;
	else
		$ru = "sip:"+$rU+"@"+$rd;

#!ifdef WITH_RX
	if ($expires(min) != 0) {
		xlog("L_DBG","Subscribing to signalling bearer status\n");

		Rx_AAR_Register("REG_AAR_REPLY", "location");
		switch ($retcode) {
			case -1:
				# There was an error sending the AAR-Request:
				xlog("L_ERR", "Diameter: AAR failed on subscription to signalling\n");
				send_reply("403", "Can't register to QoS for signalling");
				exit;
				break;
			case 0:
				# We are waiting for an async reply, just exit here.
				exit;
				break;
			case 1:
				# We did not need to send AAR, so just continue as normal
				route(REGISTER_CONTINUE);
				break;
		}
	} else {
		# Proceed with Registering:
		route(REGISTER_CONTINUE);
	}
	exit;
}

route[REG_AAR_REPLY] {
	switch ($avp(s:aar_return_code)) {
		case 1:
			xlog("L_DBG", "Diameter: AAR success on subscription to signalling\n");
			break;
		default:
			xlog("L_ERR", "Diameter: AAR failed on subscription to signalling\n");
			send_reply("403", "Can't register to QoS for signalling");
			exit;
	}
	# Proceed with Registering:
	route(REGISTER_CONTINUE);
}

route[REGISTER_CONTINUE] {
#!endif
    # Path header
    append_hf("Path: <sip:term@HOSTNAME;lr>\r\n");

    # Support and Require headers
    remove_hf("Supported");
    append_hf("Supported: path\r\n");
    remove_hf("Require");
    append_hf("Require: path\r\n");

#!ifdef WITH_MULTIPLMN
    # Enhanced P-Visited-Network-ID handling based on PLMN
    if (is_present_hf("P-Visited-Network-ID")) {
        $var(existing_visited) = $hdr(P-Visited-Network-ID);
        if ($avp(plmn_full) != "" && $avp(plmn_full) != "432080") {
            # Roaming: set to visited network
            $var(new_hdr_val) = "ims.mnc" + $avp(plmn_mnc) + ".mcc" + $avp(plmn_mcc) + ".3gppnetwork.org, " + $var(existing_visited);
        } else {
            # Home: set to home network
            $var(new_hdr_val) = "ims.mnc080.mcc432.3gppnetwork.org, " + $var(existing_visited);
        }
        remove_hf("P-Visited-Network-ID");
        $var(hdr_line) = "P-Visited-Network-ID: " + $var(new_hdr_val) + "\r\n";
        append_hf("$var(hdr_line)");
        xlog("L_INFO", "PCSCF REGISTER: Updated P-Visited-Network-ID: $var(new_hdr_val)\n");
    } else {
        if ($avp(plmn_full) != "" && $avp(plmn_full) != "432080") {
            $var(new_hdr_val) = "ims.mnc" + $avp(plmn_mnc) + ".mcc" + $avp(plmn_mcc) + ".3gppnetwork.org";
        } else {
            $var(new_hdr_val) = "ims.mnc080.mcc432.3gppnetwork.org";
        }
        $var(hdr_line) = "P-Visited-Network-ID: " + $var(new_hdr_val) + "\r\n";
        append_hf("$var(hdr_line)");
        xlog("L_INFO", "PCSCF REGISTER: Added P-Visited-Network-ID: $var(new_hdr_val)\n");
    }

    # Add P-Access-Network-Info for enhanced PLMN context
    if (!is_present_hf("P-Access-Network-Info") && $avp(plmn_full) != "") {
        $var(pani) = "P-Access-Network-Info: 3GPP-E-UTRAN; utran-cell-id-3gpp=" + $avp(plmn_mcc) + ":" + $avp(plmn_mnc) + "\r\n";
        append_hf("$var(pani)");
        xlog("L_INFO", "PCSCF REGISTER: Added P-Access-Network-Info for PLMN: $avp(plmn_full)\n");
    }
#!else
    # Legacy P-Visited-Network-ID handling
    if (is_present_hf("P-Visited-Network-ID")) {
        $var(existing) = $hdr(P-Visited-Network-ID);
        $var(hdr_line) = "P-Visited-Network-ID: NETWORKNAME, " + $var(existing) + "\r\n";
        append_hf("$var(hdr_line)");
    } else {
        append_hf("P-Visited-Network-ID: NETWORKNAME\r\n");
    }
#!endif

#!ifdef WITH_SBC
#!ifndef WITH_SBC_CALL
    t_on_failure("SBC_failure");
    # Choose an SBC to send the call to:
    if (!ds_select_dst(DISPATCHER_LIST_SBC, "4")) {
        send_reply("503", "Service Unavailable (SBC failure)");
        exit;
    }
#!else
    t_on_failure("REGISTER_failure");
#!endif
#!else
    t_on_failure("REGISTER_failure");
#!endif

    t_on_reply("REGISTER_reply");
    # Forward request
    route(RELAY);
    exit;
}


# Replies for REGISTER requests with PLMN-based Service-Route:
######################################################################
onreply_route[REGISTER_reply]
{
	if (t_check_status("200")) {
#!ifdef WITH_MULTIPLMN
		# Generate PLMN-specific Service-Route
		route(GENERATE_PLMN_SERVICE_ROUTE);
		
		# Handle dynamic Service-Route based on PLMN
		if (is_present_hf("Service-Route")) {
			# Remove existing Service-Route header
			remove_hf("Service-Route");
			xlog("L_INFO", "PCSCF REGISTER_REPLY: Removed existing Service-Route\n");
		}
		
		# Add PLMN-specific Service-Route
		if($avp(dynamic_service_route) != $null) {
			append_hf("Service-Route: $avp(dynamic_service_route)\r\n");
			xlog("L_INFO", "PCSCF REGISTER_REPLY: Added PLMN-specific Service-Route: $avp(dynamic_service_route)\n");
			
			# Cache the Service-Route for this call-id
			$sht(serviceroutes=>$ci) = $avp(dynamic_service_route);
		} else {
			# Fallback to default Service-Route
			$var(default_route) = "<sip:orig@scscf.ims.mnc080.mcc432.3gppnetwork.org:6060;lr>";
			append_hf("Service-Route: $var(default_route)\r\n");
			xlog("L_WARN", "PCSCF REGISTER_REPLY: Using default Service-Route: $var(default_route)\n");
			$sht(serviceroutes=>$ci) = $var(default_route);
		}
		
		msg_apply_changes();
#!else
		# Legacy Service-Route handling
#!ifdef WITH_IMS_HDR_CACHE
		if (is_present_hf("Service-Route")) {
			$sht(serviceroutes=>$ci) = $hdr(Service-Route);
		} else {
			if ($sht(serviceroutes=>$ci) != $null) {
				append_hf("Service-Route: $sht(serviceroutes=>$ci)\r\n");
				msg_apply_changes();
			}
		}
#!endif
#!endif

#!ifdef WITH_IMS_HDR_CACHE
		# Handle P-Associated-URI (unchanged)
		if (is_present_hf("P-Associated-URI")) {
			$sht(associateduris=>$ci) = $hdr(P-Associated-URI);
		} else {
			if ($sht(associateduris=>$ci) != $null) {
				append_hf("P-Associated-URI: $sht(associateduris=>$ci)\r\n");
				msg_apply_changes();
			}
		}
#!endif

#!ifdef WITH_IPBLOCK
		$sht(failedauth=>$T_req($si)) = $null;
#!endif
		pcscf_save("location");

#!ifdef WITH_MULTIPLMN
		# Store roaming user information for later use
		if($avp(plmn_full) != "" && $avp(plmn_full) != "432080") {
			$sht(roaming_users=>$T_req($fU)) = $avp(plmn_id);
			xlog("L_INFO", "PCSCF REGISTER_REPLY: Stored roaming user $T_req($fU) with PLMN: $avp(plmn_id)\n");
		}
#!endif

#!ifdef WITH_NATPING
#!ifdef WITH_PING_UDP
		#if ($T_req($pr) == "udp") {
		if ($pr == "udp") {
			sht_lock("natping=>natpinglock");
			if ($(T_req($hdr(Security-Client))) =~ ".*ipsec-3gpp.*") {
				$var(sec_client) = $(T_req($hdr(Security-Client)));
				xnotice("Security-Client=$var(sec_client)\n");
				$var(sc_port_c) = $(var(sec_client){re.subst,/.*port-c=([0-9]*).*$/\1/s});
				xnotice("port-c=$var(sc_port_c)\n");
				$var(sc_port_s) = $(var(sec_client){re.subst,/.*port-s=([0-9]*).*$/\1/s});
				xnotice("port-s=$var(sc_port_s)\n");
				$var(ouri) = "sip:"+$T_req($si)+":"+$var(sc_port_s);
			} else {
				$var(ouri) = "sip:"+$T_req($si)+":"+$T_req($sp);
			}
			$sht(natping=>$var(ouri)) = $(T_req($ct){nameaddr.uri});
			sht_unlock("natping=>natpinglock");

			sht_lock("natpingfrom=>natpingfromlock");
			if ($(T_req($hdr(Security-Verify))) =~ ".*ipsec-3gpp.*") {
				$var(sec_verify) = $(T_req($hdr(Security-Verify)));
				xnotice("Security-Verify=$var(sec_verify)\n");
				$var(sv_port_c) = $(var(sec_verify){re.subst,/.*port-c=([0-9]*).*$/\1/s});
				xnotice("port-c=$var(sv_port_c)\n");
				$var(sv_port_s) = $(var(sec_verify){re.subst,/.*port-s=([0-9]*).*$/\1/s});
				xnotice("port-s=$var(sv_port_s)\n");

				$sht(natpingfrom=>$var(ouri)) = "udp:"+$T_req($Ri)+":"+$var(sv_port_c);
			} else {
				$sht(natpingfrom=>$var(ouri)) = "udp:"+$T_req($Ri)+":"+$T_req($Rp);
			}
			sht_unlock("natpingfrom=>natpingfromlock");
		}
#!endif
#!ifdef WITH_PING_TCP
		#if ($T_req($pr) == "tcp") {
		if ($pr == "tcp") {
			sht_lock("natping=>natpinglock");
			if ($(T_req($hdr(Security-Client))) =~ ".*ipsec-3gpp.*") {
				$var(sec_client) = $(T_req($hdr(Security-Client)));
				xnotice("Security-Client=$var(sec_client)\n");
				$var(sc_port_c) = $(var(sec_client){re.subst,/.*port-c=([0-9]*).*$/\1/s});
				xnotice("port-c=$var(sc_port_c)\n");
				$var(sc_port_s) = $(var(sec_client){re.subst,/.*port-s=([0-9]*).*$/\1/s});
				xnotice("port-s=$var(sc_port_s)\n");
				$var(ouri) = "sip:"+$T_req($si)+":"+$var(sc_port_s)+";transport=tcp";
			} else {
				$var(ouri) = "sip:"+$T_req($si)+":"+$T_req($sp)+";transport=tcp";
			}
			$sht(natping=>$var(ouri)) = $(T_req($ct){nameaddr.uri});
			sht_unlock("natping=>natpinglock");

			sht_lock("natpingfrom=>natpingfromlock");
			if ($(T_req($hdr(Security-Verify))) =~ ".*ipsec-3gpp.*") {
				$var(sec_verify) = $(T_req($hdr(Security-Verify)));
				xnotice("Security-Verify=$var(sec_verify)\n");
				$var(sv_port_c) = $(var(sec_verify){re.subst,/.*port-c=([0-9]*).*$/\1/s});
				xnotice("port-c=$var(sv_port_c)\n");
				$var(sv_port_s) = $(var(sec_verify){re.subst,/.*port-s=([0-9]*).*$/\1/s});
				xnotice("port-s=$var(sv_port_s)\n");

				$sht(natpingfrom=>$var(ouri)) = "tcp:"+$T_req($Ri)+":"+$var(sv_port_c);
			} else {
				$sht(natpingfrom=>$var(ouri)) = "tcp:"+$T_req($Ri)+":"+$T_req($Rp);
			}
			sht_unlock("natpingfrom=>natpingfromlock");
		}
#!endif
#!ifdef WITH_PING_TLS
		#if ($T_req($pr) == "tls") {
		if ($pr == "tls") {
			sht_lock("natping=>natpinglock");
			if ($(T_req($hdr(Security-Client))) =~ ".*ipsec-3gpp.*") {
				$var(sec_client) = $(T_req($hdr(Security-Client)));
				xnotice("Security-Client=$var(sec_client)\n");
				$var(sc_port_c) = $(var(sec_client){re.subst,/.*port-c=([0-9]*).*$/\1/s});
				xnotice("port-c=$var(sc_port_c)\n");
				$var(sc_port_s) = $(var(sec_client){re.subst,/.*port-s=([0-9]*).*$/\1/s});
				xnotice("port-s=$var(sc_port_s)\n");
				$var(ouri) = "sip:"+$T_req($si)+":"+$var(sc_port_s)+";transport=tls";
			} else {
				$var(ouri) = "sip:"+$T_req($si)+":"+$T_req($sp)+";transport=tls";
			}
			$sht(natping=>$var(ouri)) = $(T_req($ct){nameaddr.uri});
			sht_unlock("natping=>natpinglock");

			sht_lock("natpingfrom=>natpingfromlock");
			if ($(T_req($hdr(Security-Verify))) =~ ".*ipsec-3gpp.*") {
				$var(sec_verify) = $(T_req($hdr(Security-Verify)));
			 xnotice("Security-Verify=$var(sec_verify)\n");
				$var(sv_port_c) = $(var(sec_verify){re.subst,/.*port-c=([0-9]*).*$/\1/s});
				xnotice("port-c=$var(sv_port_c)\n");
				$var(sv_port_s) = $(var(sec_verify){re.subst,/.*port-s=([0-9]*).*$/\1/s});
				xnotice("port-s=$var(sv_port_s)\n");

				$sht(natpingfrom=>$var(ouri)) = "tls:"+$T_req($Ri)+":"+$var(sv_port_c);
			} else {
				$sht(natpingfrom=>$var(ouri)) = "tls:"+$T_req($Ri)+":"+$T_req($Rp);
			}
			sht_unlock("natpingfrom=>natpingfromlock");
		}
#!endif
#!endif
		#update stats for register reply on success
		$var(start_secs) = $(sht(a=>$ci::start_time){s.select,0,.});
		$var(start_usecs) = $(sht(a=>$ci::start_time){s.select,1,.});
		$var(diff_secs) = $TV(s) - $var(start_secs);
		$var(diff_usecs) = $TV(u) - $var(start_usecs);
		$var(diff_ms) = $var(diff_secs)*1000 + ($var(diff_usecs)/1000);
		$sht(a=>$ci::start_time)=0;
		$var(stat_add) = "+" + $var(diff_ms);
		xlog("L_DBG", "REGISTER SUCCESS[$ci] took $var(stat_add)ms\n");
		update_stat("register_success", "+1");
		update_stat("register_time", "$var(stat_add)");
#!ifdef WITH_IPSEC
		ipsec_forward("location", IPSEC_FORWARD_FLAGS);
	}
	else {
		if (t_check_status("401")) {
			if($(T_req($hdr(Security-Client))) != $null && ipsec_create("location", IPSEC_DELETE_UNUSED_TUNNELS)!=1) {
				send_reply("503", "Service Unavailable (Create ipsec failed)");
			}
			if ($sht(ipsec_clients=>$(T_req($ct){nameaddr.uri})) != $null) {
				$var(sec_client) = $(T_req($hdr(Security-Client)));
				xnotice("Security-Client=$var(sec_client)\n");
				$var(sc_port_c) = $(var(sec_client){re.subst,/.*port-c=([0-9]*).*$/\1/s});
				xnotice("port-c=$var(sc_port_c)\n");
				$var(sc_port_s) = $(var(sec_client){re.subst,/.*port-s=([0-9]*).*$/\1/s});
				xnotice("port-s=$var(sc_port_s)\n");
			}
			xnotice("Expires=$(T_req($expires(min)))\n");
			if (is_present_hf("WWW-Authenticate")) {
				# Remove ck and ik:
				$var(old_hdr) = $hdr(WWW-Authenticate);
				xnotice("Old header - WWW-Authenticate=$var(old_hdr)\n");
				remove_hf("WWW-Authenticate");
				$var(new_hdr) = $(hdr(WWW-Authenticate){re.subst,/(, *)?(ck|ik)=\"\w+\"//gi});
				if ($(var(new_hdr){s.len}) > 0) {
					append_hf("WWW-Authenticate: $var(new_hdr)\r\n");
				}
				xnotice("New header - WWW-Authenticate=$var(new_hdr)\n");
			}
		}
#!endif
	}
	exit;
}

#!ifdef WITH_MULTIPLMN
######################################################################
# Generate PLMN-specific Service-Route
######################################################################
route[GENERATE_PLMN_SERVICE_ROUTE] {
	# Get UE's PLMN if not already extracted
	if($avp(plmn_full) == $null || $avp(plmn_full) == "") {
		route(EXTRACT_PLMN_INFO);
	}
	
	# Generate PLMN-specific Service-Route
	$var(scscf_domain) = $sht(plmn_scscf_mapping=>$avp(plmn_full));
	if ($var(scscf_domain) != $null && $var(scscf_domain) != "") {
		$var(service_route) = "<sip:orig@" + $var(scscf_domain) + ":6060;lr>";
		$avp(dynamic_service_route) = $var(service_route);
		xlog("L_INFO", "PCSCF REGISTER: Generated PLMN-specific Service-Route for PLMN $avp(plmn_full): $var(service_route)\n");
	} else {
		# Fallback to default Service-Route based on home PLMN
		$var(default_route) = "<sip:orig@scscf.ims.mnc080.mcc432.3gppnetwork.org:6060;lr>";
		$avp(dynamic_service_route) = $var(default_route);
		xlog("L_WARN", "PCSCF REGISTER: No SCSCF mapping found for PLMN $avp(plmn_full), using default home network route: $var(default_route)\n");
	}
	
	return;
}
#!endif

# Negative replies to REGISTER requests - Enhanced with Multi-PLMN support:
######################################################################
failure_route[REGISTER_failure]
{
#!ifdef WITH_MULTIPLMN
	# Enhanced logging for roaming registration failures
	if($avp(plmn_full) != "" && $avp(plmn_full) != "432080") {
		xlog("L_WARN", "PCSCF REGISTER: Registration failure for roaming user from PLMN: $avp(plmn_id)\n");
	}
#!endif

#!ifdef WITH_IPBLOCK
	if (t_check_status("403|[5-6][0-9][0-9]")) {
		if ($sht(failedauth=>$si) != $null)
			$sht(failedauth=>$si) = $sht(failedauth=>$si) + 1;
		else
			$sht(failedauth=>$si) = 1;
		if ($sht(failedauth=>$si) > 10) {
			xlog("L_ALERT","ALERT: blocking $rm from $fu (IP:$si:$sp), more than 5 failed auth requests!\n");
			xlog("Blocking traffic from $si\n");
			$sht(ipban=>$si) = 1;
		}
				update_stat("register_failed", "+1");
	}
#!endif
	if (t_check_status("408")) {
		send_reply("504","Server Time-Out");
				update_stat("register_failed", "+1");
		exit;
	}
}
